<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>曾几何时</title><link rel="stylesheet" href="/css/index.css"><link rel="icon" href="/superman.ico"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script>/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */
"document"in self&&("classList"in document.createElement("_")&&(!document.createElementNS||"classList"in document.createElementNS("http://www.w3.org/2000/svg","g"))?!function(){"use strict";var t=document.createElement("_");if(t.classList.add("c1","c2"),!t.classList.contains("c2")){var e=function(t){var e=DOMTokenList.prototype[t];DOMTokenList.prototype[t]=function(t){var n,i=arguments.length;for(n=0;i>n;n++)t=arguments[n],e.call(this,t)}};e("add"),e("remove")}if(t.classList.toggle("c3",!1),t.classList.contains("c3")){var n=DOMTokenList.prototype.toggle;DOMTokenList.prototype.toggle=function(t,e){return 1 in arguments&&!this.contains(t)==!e?e:n.call(this,t)}}t=null}():!function(t){"use strict";if("Element"in t){var e="classList",n="prototype",i=t.Element[n],s=Object,r=String[n].trim||function(){return this.replace(/^\s+|\s+$/g,"")},o=Array[n].indexOf||function(t){for(var e=0,n=this.length;n>e;e++)if(e in this&&this[e]===t)return e;return-1},c=function(t,e){this.name=t,this.code=DOMException[t],this.message=e},a=function(t,e){if(""===e)throw new c("SYNTAX_ERR","An invalid or illegal string was specified");if(/\s/.test(e))throw new c("INVALID_CHARACTER_ERR","String contains an invalid character");return o.call(t,e)},l=function(t){for(var e=r.call(t.getAttribute("class")||""),n=e?e.split(/\s+/):[],i=0,s=n.length;s>i;i++)this.push(n[i]);this._updateClassName=function(){t.setAttribute("class",this.toString())}},u=l[n]=[],h=function(){return new l(this)};if(c[n]=Error[n],u.item=function(t){return this[t]||null},u.contains=function(t){return t+="",-1!==a(this,t)},u.add=function(){var t,e=arguments,n=0,i=e.length,s=!1;do t=e[n]+"",-1===a(this,t)&&(this.push(t),s=!0);while(++n<i);s&&this._updateClassName()},u.remove=function(){var t,e,n=arguments,i=0,s=n.length,r=!1;do for(t=n[i]+"",e=a(this,t);-1!==e;)this.splice(e,1),r=!0,e=a(this,t);while(++i<s);r&&this._updateClassName()},u.toggle=function(t,e){t+="";var n=this.contains(t),i=n?e!==!0&&"remove":e!==!1&&"add";return i&&this[i](t),e===!0||e===!1?e:!n},u.toString=function(){return this.join(" ")},s.defineProperty){var f={get:h,enumerable:!0,configurable:!0};try{s.defineProperty(i,e,f)}catch(d){void 0!==d.number&&-2146823252!==d.number||(f.enumerable=!1,s.defineProperty(i,e,f))}}else s[n].__defineGetter__&&i.__defineGetter__(e,h)}}(self));
</script></head><body><header><div class="description"><a href="/"><img class="logo" src="/logo.png"></a><p></p></div><div class="search"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">Search</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><nav><ul class="nav"><li><a href="/" target="_self">HOME</a></li><li><a href="/archives/" target="_self">ARCHIVES</a></li><li><a href="https://github.com/ycwalker/hexo-theme-cutie" target="_blank">THEME</a></li><li><a href="https://github.com/liuhui1993" target="_blank">GITHUB</a></li></ul></nav></header><aside><button class="toggle expand"><span class="item1"></span><span class="item2"></span><span class="item3"></span></button><div class="directory hide"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NodeJS入门"><span class="toc-number">1.</span> <span class="toc-text">NodeJS入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、基本概念"><span class="toc-number">1.1.</span> <span class="toc-text">一、基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、NodeJS服务器搭建"><span class="toc-number">1.2.</span> <span class="toc-text">二、NodeJS服务器搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#REPL执行环境"><span class="toc-number">1.3.</span> <span class="toc-text">REPL执行环境</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#体验在node-exe-REPL-中执行hello-world"><span class="toc-number">2.</span> <span class="toc-text">体验在node.exe(REPL)中执行hello world</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器–服务器间的请求响应"><span class="toc-number">2.1.</span> <span class="toc-text">浏览器–服务器间的请求响应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主机名代表找哪一台服务器，端口是用来区分不同软件-不同软件在服务器端有对应端口号"><span class="toc-number">2.2.</span> <span class="toc-text">主机名代表找哪一台服务器，端口是用来区分不同软件(不同软件在服务器端有对应端口号)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node的模块化思想"><span class="toc-number">2.3.</span> <span class="toc-text">Node的模块化思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node核心模块之HTTP模块"><span class="toc-number">2.4.</span> <span class="toc-text">Node核心模块之HTTP模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用http核心模块，开启web服务器"><span class="toc-number">2.4.1.</span> <span class="toc-text">使用http核心模块，开启web服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node核心模块之URL模块"><span class="toc-number">2.5.</span> <span class="toc-text">Node核心模块之URL模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NodeJS核心模块之Query-Strings模块"><span class="toc-number">2.6.</span> <span class="toc-text">NodeJS核心模块之Query Strings模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NodeJS核心模块之Buffer模块"><span class="toc-number">2.7.</span> <span class="toc-text">NodeJS核心模块之Buffer模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NodeJS核心模块之File-System模块"><span class="toc-number">2.8.</span> <span class="toc-text">NodeJS核心模块之File System模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NodeJS核心模块之Path模块"><span class="toc-number">2.9.</span> <span class="toc-text">NodeJS核心模块之Path模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NodeJS核心模块之Global模块"><span class="toc-number">2.10.</span> <span class="toc-text">NodeJS核心模块之Global模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义模块"><span class="toc-number">2.11.</span> <span class="toc-text">自定义模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6语法"><span class="toc-number">2.12.</span> <span class="toc-text">ES6语法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#npm的介绍"><span class="toc-number">3.</span> <span class="toc-text">npm的介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#npm操作之从npmjs-com中安装-下载包"><span class="toc-number">4.</span> <span class="toc-text">npm操作之从npmjs.com中安装/下载包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#require-加载规则"><span class="toc-number">5.</span> <span class="toc-text">require()加载规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP模块处理静态资源"><span class="toc-number">6.</span> <span class="toc-text">HTTP模块处理静态资源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#http模块实现动态网页"><span class="toc-number">7.</span> <span class="toc-text">http模块实现动态网页</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#不使用模版"><span class="toc-number">8.</span> <span class="toc-text">不使用模版</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用模版"><span class="toc-number">9.</span> <span class="toc-text">使用模版</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#package-json"><span class="toc-number">10.</span> <span class="toc-text">package.json</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#学习途径"><span class="toc-number">11.</span> <span class="toc-text">学习途径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CPU处理指令集"><span class="toc-number">12.</span> <span class="toc-text">CPU处理指令集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cmd控制台常用指令及powershell介绍"><span class="toc-number">13.</span> <span class="toc-text">cmd控制台常用指令及powershell介绍</span></a></li></ol></div><script>var toggle = document.querySelector('.toggle')
toggle.addEventListener('click', function () {
  this.classList.toggle('expand')
  document.querySelector('.directory').classList.toggle('hide')
  document.querySelector('.post').classList.toggle('post-expand')
})</script><script>setTimeout(document.body.click.bind(toggle), 300)</script></aside><article class="post post-content post-expand"><h1>NodeJS基础</h1><time>Feb 2, 2017</time><h1 id="NodeJS入门"><a href="#NodeJS入门" class="headerlink" title="NodeJS入门"></a>NodeJS入门</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><pre><code>1. 用js写的后台语言之一，代码放在服务器中执行(后台语言：php，java,net...)
2. 作用：提供数据(为前端)，数据统计，权限验证...
3. 特点：事件驱动：(比如为按钮绑定事件，点击按钮触发事件)；非阻塞式I/O(异步，不会卡主浏览器)
4. 简单的理解就是来做后台开发的
</code></pre><hr>
<h2 id="二、NodeJS服务器搭建"><a href="#二、NodeJS服务器搭建" class="headerlink" title="二、NodeJS服务器搭建"></a>二、NodeJS服务器搭建</h2><pre><code>1. 下载软件
2. 系统环境变量(如果命令行输入node命令出错时，配置一下环境变量)
3. 如何判断有没有安装成功:
在cmd终端中输入 node -v 看有没有提示,如果有提示就说明
安装成功了,如果没有,还需要做下一步
</code></pre><hr>
<h2 id="REPL执行环境"><a href="#REPL执行环境" class="headerlink" title="REPL执行环境"></a>REPL执行环境</h2><blockquote>
<p>就是操作系统给node.exe分配的内存空间，有了这段空间后，就可以执行js代码了(前天是启动node.exe)<br>它就是我们NodeJS代码的运行环境</p>
</blockquote>
<p>  前提:<br>    我们的NodeJS的代码不是运行在浏览器中的,那他运行在哪里呢?</p>
<p>  基本概念:<br>    1.REPL就是Node.exe 启动起来之后的运行环境</p>
<pre><code>2.REPL 可以理解成类似于`启动起来的`Apache服务器

3.Node.exe(REPL)环境启动之后,就会执行放入它里面的NodeJS代码了,类似于启动Apache服务器之后就可以运行放入它里面的php代码了

4.js代码放入到node.exe中就可以执行运行起来了
</code></pre><hr>
<h1 id="体验在node-exe-REPL-中执行hello-world"><a href="#体验在node-exe-REPL-中执行hello-world" class="headerlink" title="体验在node.exe(REPL)中执行hello world"></a>体验在node.exe(REPL)中执行hello world</h1><p>  书写代码的步骤:<br>    1.建立一个xxx.js文件<br>    2.在里面写一句话 console.log(“hello world”);</p>
<p>  用node.exe执行的步骤:<br>    1.启动终端,并切换到xxx.js所对应的目录<br>    2.在终端中输入 node xxx.js 即可以执行xxx.js中的js代码</p>
<p>  运行过程分析:在终端中输入 node xxx.js究竟做了什么事呢?<br>    1.首先会启动 node.exe 这个应用程序<br>    2.操作系统会给 node.exe 开辟一块内存,供node.exe来使用<br>    3.node.exe 会把 xxx.js文件的内容加载到 node.exe的内存中<br>    4.node.exe 解析和执行文件中的代码<br>    5.最后将结果(hello world)打印输出到了控制台中<br>    6.node.exe<code>在这个时候</code>执行完毕之后就退出了,因为这个地方<br>    逻辑比较简单</p>
<p>  注意点:<br>    要区分和浏览器中js执行过程的不同</p>
<h2 id="浏览器–服务器间的请求响应"><a href="#浏览器–服务器间的请求响应" class="headerlink" title="浏览器–服务器间的请求响应"></a>浏览器–服务器间的请求响应</h2><p>浏览器通过向主机名端口号发送请求，服务器按原路径返回响应</p>
<h2 id="主机名代表找哪一台服务器，端口是用来区分不同软件-不同软件在服务器端有对应端口号"><a href="#主机名代表找哪一台服务器，端口是用来区分不同软件-不同软件在服务器端有对应端口号" class="headerlink" title="主机名代表找哪一台服务器，端口是用来区分不同软件(不同软件在服务器端有对应端口号)"></a>主机名代表找哪一台服务器，端口是用来区分不同软件(不同软件在服务器端有对应端口号)</h2><h2 id="Node的模块化思想"><a href="#Node的模块化思想" class="headerlink" title="Node的模块化思想"></a>Node的模块化思想</h2><p>  模块化:<br>    将一些功能相似的代码,统一放在一个文件或是文件夹中,然后暴露出去,给其它人用,这种思想称之为模块化思想</p>
<p>  NodeJS中的模块化思想体现:<br>    在NodeJS中,不同的功能放在不同的模块中,比如<br>    Node中将文件操作放在File System 模块中,将路<br>    径相关的功能放在Path中,将url相关的功能放在URL<br>    模块中,将网络请求功能的代码放在HTTP模块中</p>
<p>  Node中模块的分类<br>    核心模块 : NodeJS本身提供</p>
<pre><code>  以下是常用的核心模块及作用：
  | 核心模块名   |       作用       |
  |-------------|---------------- |
  | http        | 网络操作         |
  | url         | url操作处理      |
  | querystring | 参数处理        |
  | fs          | 文件操作         |
  | path        | 文件路径操作     |



自定义模块 : 程序员基于NodeJS写的功能块代码
    说白了就是自己写的模块
    自己开发模块,需要使用到三个关键函数 require module.exports exports

第三方模块(包) : 
  也称之为包,主要集中在npmjs.com上面
</code></pre><hr>
<h2 id="Node核心模块之HTTP模块"><a href="#Node核心模块之HTTP模块" class="headerlink" title="Node核心模块之HTTP模块"></a>Node核心模块之HTTP模块</h2><h3 id="使用http核心模块，开启web服务器"><a href="#使用http核心模块，开启web服务器" class="headerlink" title="使用http核心模块，开启web服务器"></a>使用http核心模块，开启web服务器</h3><ol>
<li><p>导入http核心模块(使用关键字require)</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);<span class="comment">//拿到了整个http模块</span></div></pre></td></tr></table></figure>
</li>
<li><p>创建服务器</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> server = http.createServer();</div></pre></td></tr></table></figure>
</li>
<li><p>请求–处理–响应(监听请求，处理之后，将数据返回回去)</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sever.on(<span class="string">'request'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</div><div class="line"><span class="comment">//req是request  请求; res是response 响应</span></div><div class="line">    <span class="built_in">console</span>.log(req.url);<span class="comment">//打印的是请求路径</span></div><div class="line"><span class="comment">//返回数据</span></div><div class="line">    res.end(<span class="string">'hello node'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>启动服务器</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">*参数1：端口号</div><div class="line">*参数2：主机地址(IP)</div><div class="line">*参数3：启动成功与否的回调</div><div class="line">*/</div><div class="line">server.listen(<span class="number">3000</span>,<span class="string">'127.0.0.1'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="comment">//如果启动成功err就没有值</span></div><div class="line">    <span class="comment">//如果没有启动成功 err就有值，值就是错误信息</span></div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">  <span class="built_in">console</span>.log(err)</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'启动服务器成功'</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id="Node核心模块之URL模块"><a href="#Node核心模块之URL模块" class="headerlink" title="Node核心模块之URL模块"></a>Node核心模块之URL模块</h2><p>  作用:<br>    处理客户端请求过来的URL</p>
<p>  代码步骤:<br>    1.导入 URL 核心模块<br>    2.导入 HTTP 核心模块<br>    3.监听客户端的请求<br>    在这中间处理客户端请求过来的URL<br>    4.处理客户端的请求<br>    5.开启服务器 </p>
<hr>
<h2 id="NodeJS核心模块之Query-Strings模块"><a href="#NodeJS核心模块之Query-Strings模块" class="headerlink" title="NodeJS核心模块之Query Strings模块"></a>NodeJS核心模块之Query Strings模块</h2><p>  作用:处理客户端通过<code>get/post</code>请求传递过来的参数</p>
<p>  使用关键点:<br>    1.需要导入 ‘querystring’ 这个核心模块<br>    2.<code>get</code>请求时 querystring 一般是配合 url 核心模块一起使用的<br>    3.<code>get/post</code>请求最终都需要调用 querystring.parse方法,<br>    将请求传递过来的键值对字符串转成js对象,方便操作</p>
<p>  注意:<br>    get/post的请求方式是不一样的,客户端传递过来时,参数放在<br>    的地方是不一样的,所以服务器端处理方式也不太一样</p>
<p>  GET：参数放在url后面<br>      1.通过url获取到urlObj的queryuname=zhangsan&amp;pwd=123<br>      2.再通过querystring,将query转成js对象<br>  POST:参数放在请求体<br>      1.监听 data  (request的事件  这个事件的方法可能会被调用多次，具体调用多少次，得根据传递数据的长度决定，所以需要拼接字符串)  表示node.exe获取post请求体中的数据<br>      2.监听 end 事件代表node.exe已经完全接收完post请求体中的数据(浏览器把所有的数据都发送过来了)<br>      3.再通过querystring,将键值对字符串转成js对象</p>
<hr>
<h2 id="NodeJS核心模块之Buffer模块"><a href="#NodeJS核心模块之Buffer模块" class="headerlink" title="NodeJS核心模块之Buffer模块"></a>NodeJS核心模块之Buffer模块</h2><pre><code>不管是请求还是响应发送的数据底层都是二进制
buffer对象的toString()方法，这个包不用导入，因为所有的数据都是二进制的，node自动导了
buffer对象.toString()
</code></pre><hr>
<h2 id="NodeJS核心模块之File-System模块"><a href="#NodeJS核心模块之File-System模块" class="headerlink" title="NodeJS核心模块之File System模块"></a>NodeJS核心模块之File System模块</h2><p>  1.读取单个文件<br>  前提:以后的所有静态资源(html,css,js,图片等)都是放在服务端<br>  的,如果浏览器需要这些html,css,js,图片等资源,则需要先将其读<br>  取到node.exe的内容中,然后再返回给浏览器</p>
<p>  作用:<br>    在服务端来操作文件,可能是需要将浏览器上传的图片保存到服<br>    务器,也可能是需要将服务器的资源读取之后返回给浏览器</p>
<p>  代码步骤:<br>    1.导入 fs 核心模块<br>    2.使用相应的方法来写入文件、读取文件等操作</p>
<p>  注意点:<br>    目录 fs它是不会自动帮我们创建的需要我们自己手工创建<br>    文件如果不存在,调用writeFile(覆盖写入)与appendFile(追加写入)方法会自动帮<br>    我们创建<br>  2.对文件夹进行操作(创建、删除、判断是否存在)<br>      服务端分门别类进行存储，减少磁盘碎片<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>读取单个文件</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *参数1：文件的路径</div><div class="line">     * 参数2：可选</div><div class="line">     * 参数3：回调</div><div class="line">     */</div><div class="line">    <span class="comment">//使用fs的异步函数来读取文件(异步通过回调返回数据)</span></div><div class="line">    <span class="comment">//node 不支持GBK 支持ASCII UTF-8</span></div><div class="line">    fs.readFile(filePath,(err,data)=&gt;&#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">console</span>.log(data.toString());</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * 使用GBK来读取data中的二进制内容</div><div class="line">       */</div><div class="line">     <span class="comment">// const str = iconv.decode(data, 'GBK');</span></div><div class="line">      <span class="comment">//console.log(str);</span></div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//使用fs的同步函数来读取文件(同步通过返回值获取数据)</span></div><div class="line">    <span class="comment">/*const content = fs.readFileSync(filePath);</span></div><div class="line">    console.log(content.toString());*/</div><div class="line">    <span class="number">2.</span>对文件夹进行操作</div><div class="line">    <span class="comment">//const dirPath = './abc'; //相对路径</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// __dirname 前面是两个下划线</span></div><div class="line">    </div><div class="line">    <span class="keyword">const</span> dirPath = path.join(__dirname,<span class="string">'abc'</span>);</div><div class="line">    </div><div class="line">    创建文件夹</div><div class="line">    fs.mkdir(dirPath,(err)=&gt;&#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">      &#125;</div><div class="line">    </div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"create success"</span>);</div><div class="line">    &#125;)</div><div class="line">    </div><div class="line">    <span class="comment">//判断文件夹/文件是否存在</span></div><div class="line">    fs.exists(dirPath, (exists)=&gt;&#123;</div><div class="line">      <span class="keyword">if</span> (exists) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'已经存在该文件夹了'</span>);</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">    </div><div class="line">      fs.mkdir(dirPath,(err)=&gt;&#123;</div><div class="line">        <span class="keyword">if</span> (err) &#123;</div><div class="line">          <span class="built_in">console</span>.log(err);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"create success"</span>);</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line">    </div><div class="line">    fs.exists(dirPath, (exists)=&gt;&#123;</div><div class="line">      <span class="keyword">if</span> (!exists) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'不存在文件夹,不需要删除'</span>);</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">    </div><div class="line">      fs.rmdir(dirPath,(err)=&gt;&#123;</div><div class="line">        <span class="keyword">if</span> (err) &#123;</div><div class="line">          <span class="built_in">console</span>.log(err); </div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'delete success'</span>);</div><div class="line">      &#125;);</div><div class="line">    &#125;)</div><div class="line">    </div><div class="line">    <span class="number">3.</span>文件写入的两种方式</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *文件有一个特点 如果没有创建则帮我自动创建,但是文件夹不会,如果没有得自己创建</div><div class="line">     * </div><div class="line">     */</div><div class="line">        <span class="keyword">const</span> filePath = path.join(__dirname,<span class="string">'123.txt'</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">const</span> newFilePath = path.join(__dirname,<span class="string">'666.txt'</span>);</div><div class="line">     <span class="comment">/*</span></div><div class="line">      文件的写入有两种方式</div><div class="line">    </div><div class="line">      第一种 覆盖写入 fs.writeFile();</div><div class="line">      第二种 追加写入 fs.appendFile()</div><div class="line">    **/</div><div class="line">    fs.writeFile(filePath,<span class="string">"覆盖了"</span>,(err)=&gt;&#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">      &#125;</div><div class="line">    </div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'write success'</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    </div><div class="line">    fs.appendFile(filePath,<span class="string">"\r\n追加"</span>,(err)=&gt;&#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'append success'</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 重命名</div><div class="line">     */</div><div class="line">    fs.rename(filePath,newFilePath,(err)=&gt;&#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">      &#125;</div><div class="line">    </div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'rename success'</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     *删除文件 unlink</div><div class="line">     * 最好判断文件是否存在</div><div class="line">     */</div><div class="line">    fs.exists(newFilePath,(exists)=&gt;&#123;</div><div class="line">        <span class="keyword">if</span> (!exists) &#123;</div><div class="line">          <span class="built_in">console</span>.log(<span class="string">'不存在该文件了'</span>);</div><div class="line">          <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        fs.unlink(newFilePath,(err)=&gt;&#123;</div><div class="line">          <span class="keyword">if</span> (err) &#123;</div><div class="line">            <span class="built_in">console</span>.log(err);</div><div class="line">          &#125;</div><div class="line">    </div><div class="line">          <span class="built_in">console</span>.log(<span class="string">'unlink success'</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     *监控</div><div class="line">     *</div><div class="line">     * curr 代码表当前文件的状态</div><div class="line">     * prev 代表之前文件的那个状态</div><div class="line">     */</div><div class="line">    <span class="comment">/*fs.watchFile(path.join(__dirname,'abc.txt'),(curr, prev) =&gt; &#123;</span></div><div class="line">      console.log(`the current mtime is: $&#123;curr.mtime&#125;`);</div><div class="line">      console.log(`the previous mtime was: $&#123;prev.mtime&#125;`);</div><div class="line">    &#125;)*/</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="NodeJS核心模块之Path模块"><a href="#NodeJS核心模块之Path模块" class="headerlink" title="NodeJS核心模块之Path模块"></a>NodeJS核心模块之Path模块</h2><p>  作用:操作文件的路径,为文件操作服务</p>
<p>  常用的几个函数:<br>    path.join(第一个路径,第二个路径) : 拼接路径</p>
<hr>
<h2 id="NodeJS核心模块之Global模块"><a href="#NodeJS核心模块之Global模块" class="headerlink" title="NodeJS核心模块之Global模块"></a>NodeJS核心模块之Global模块</h2><p>  作用:全局共享的,不需要导入模块即可以使用</p>
<p>  常用的属性:<br>    <strong>dirname : 文件所在的文件夹路径
    </strong>filename : 文件所在的路径<br>    require() : 导入需要的模块<br>    module : 自定义模块时用到<br>    exports : 自定义模块时用到</p>
<pre><code>moudule.exports/exoprts
  如果你要导出一个成员大于或等于一个:1.module.exports.属性名称= 属性值
                            2.exports.属性名称= 属性值
   如果你导出的成员只用一个:module.exports = 属性名称                       
</code></pre><hr>
<h2 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h2><pre><code>require() 导入fs的核心模块、第三方模块、自定义模块，导入自定义的模块,需要加上路径及拓展名

module.exports 导出单个对象/属性/函数

exports.xxx = xxx 可以导出一个或是多个对象/属性/函数
</code></pre><p>  注意点:<br>    module.exports与exports 都可以导出对象/属性/函数,但是一个适合导出单个,另外一个适合导出一个或是多个</p>
<pre><code>通过require()导入另外一个自定义模块,其实是导入另外一个自定义模块中`exports`所指向的东西
</code></pre><hr>
<h2 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h2><p>在使用es6的时候，开启严格模式 ‘use strict’</p>
<ul>
<li>let <ul>
<li>变量(相当于var)</li>
</ul>
</li>
<li>const <ul>
<li>常量  不可更改(不能改变对象的指向，但可以改变值)</li>
</ul>
</li>
<li>字符串的一些方法<ul>
<li>string.includes(‘字符串’)  判断字符串中是否包含某个字符串 返回布尔值</li>
<li>string.startsWith(‘字符串’) 判断是否是某个字符串开始<ul>
<li>应用场景：判断URL的协议</li>
<li>http/https</li>
</ul>
</li>
<li>string.endsWith 判断是否是某个字符串结尾</li>
<li>应用场景：判断文件的后缀<ul>
<li>.jpg .mp4</li>
</ul>
</li>
</ul>
</li>
<li>定义函数方式改为箭头函数<ul>
<li>格式：</li>
<li>const/let 函数名称 = (形参1，形参2) =&gt;{<br>  方法体<br>}</li>
</ul>
</li>
</ul>
<hr>
<h1 id="npm的介绍"><a href="#npm的介绍" class="headerlink" title="npm的介绍"></a>npm的介绍</h1><p>  npm是用来管理nodejs第三方包的一个工具,利用它可以<br>    1.安装 本地包/全局包<br>    2.将自己写的包发布到npmjs上面去,供全世界的开发者使用</p>
<p>  npm在安装好node之后,就会自动安装到node的安装目录中,一般是安装在node根目录的node_modules的子文件夹下,比如我的npm就安装在 C:\Program Files\nodejs\node_modules</p>
<p>  如何测试npm是否安装成功,在终端中输入 npm -v 如果能出现版本号就表示安装成功</p>
<h1 id="npm操作之从npmjs-com中安装-下载包"><a href="#npm操作之从npmjs-com中安装-下载包" class="headerlink" title="npm操作之从npmjs.com中安装/下载包"></a>npm操作之从npmjs.com中安装/下载包</h1><p>  安装包/下载包分两种</p>
<pre><code>本地安装:用在当前项目中
  命令:npm install 本地包的名称

全局安装:以后在终端中使用
  命令:npm install -g 全局包的名称

  其它命令:
  1.查看全局包安装路径:npm root -g

  2.更改全部安装包安装路径:npm config set fix &quot;全局包的路径&quot;
    当我们用 `npm install - g 全局包的名称` 这个指令的时候,有的时候全局包可能
</code></pre><hr>
<hr>
<h1 id="require-加载规则"><a href="#require-加载规则" class="headerlink" title="require()加载规则"></a>require()加载规则</h1><p>  基本概念:<br>    1.核心模块、自定义模块(自己写的模块)、第三方包都优先从缓存加载<br>    2.在windows中加载一个自定义模块(自己写的模块)要使用 ./ 或者 ../ 开头</p>
<p>  自定义模块(自己写的模块)加载规则:<br>    一个自定义模块可以不写扩展名， require()会自动依次按照 .js .node .json的顺序进行补齐后加载，如果三个扩展名都没有，则当做核心模块或者包加载，如果核心模块或者包都没有，则报错</p>
<pre><code>开发建议:自定义模块最好写扩展名,提高查找效率
</code></pre><p>  require加载第三方包的规则：<br>    依次按照module.paths 数组中的路径，根据传入require的标识符名称进行查找，如果都没有查找到标识符名称的包，则报错</p>
<pre><code>找到node_modules之后再加载具体第三方包(以xtpl为例)规则:
  1.如果包下有package.json 文件，并且其中的main 属性配置的文件能够找到，则加载此文件
  2.如果package.json文件没有，或者它里面main属性配置的文件名不能找到，则默认加载当前文件夹下的index.js
  3.如果都没有找到则报错      
</code></pre><p>  总结:require()加载node_modules的时候是按照module.paths 数组中的路径一个个查找，直到找到为止</p>
<p>  使用require这个导入json,就会将json中的内容转成js对象</p>
<hr>
<h1 id="HTTP模块处理静态资源"><a href="#HTTP模块处理静态资源" class="headerlink" title="HTTP模块处理静态资源"></a>HTTP模块处理静态资源</h1><pre><code>前提:
  以后所有的静态资源(html,css,js,图片)以及NodeJS写的代码都是放在
  服务器端的

如何访问呢?
  当浏览器发送请求,请求某个网页之后,会将这个请求发送到后台服务器
  node.exe,然后根据路由规则交给对应的js去处理,在js里面就去将静态资源
  读取到内存,经过一番处理之后返回给浏览器去展示
  如果返回的网页中,还需要进一步请求,比如网页中要用到某个.css文件,这个
  时候同样会发送网络请求给服务器node.exe,服务器同样还是按照上面的步骤进行处理,先读取到REPL环境中来,然后经过处理之后返回给浏览器

注意点:
  浏览器可能访问的服务器资源是不一样的,比如浏览器可能需要html,可能需
  要css,也可能需要图片,所以服务器返回资源的时候一定要告诉浏览器
  我给你返回的到底是啥,这个时候就一定要在响应头中增加一个键值对
  key就是Content-Type,值则根据你给浏览器返回的是啥,你就写啥
</code></pre><hr>
<h1 id="http模块实现动态网页"><a href="#http模块实现动态网页" class="headerlink" title="http模块实现动态网页"></a>http模块实现动态网页</h1><h1 id="不使用模版"><a href="#不使用模版" class="headerlink" title="不使用模版"></a>不使用模版</h1><pre><code>1.去读取模版的内容
2.利用数据生成新的元素
3.利用新的元素替换模版中的占位符

缺点：代码太多
   容易出错
</code></pre><h1 id="使用模版"><a href="#使用模版" class="headerlink" title="使用模版"></a>使用模版</h1><pre><code>成套的模版，既包含前端也包含nodejs

https://github.com/xtemplate/xtemplate/blob/master/docs/syntax-cn.md 网页使用的

https://github.com/xtemplate/xtpl NodeJS使用的

注意:
  这个模版要配合起来使用，除了写html里面的模版，还要写nodejs中的代码
</code></pre><hr>
<h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><pre><code>作用:
  1.每个Node项目中及第三方包中都必须的
  2.它描述着Node项目或是第三方包的一些信息
  3.透过这些信息可以知道该Node项目或是第三方包运行起来要依赖于哪些第三方包
  4.还可以在里面写一些终端执行脚本,在package.json的scripts中进行定义

使用步骤:
  1.打开终端cmd或是powershell
  2.切换到该Node项目的根目录下面去
  3.执行 npm init -y 或是 npm init 生成package.json
  4.在开发过程中安装第三方包的时候这样写 npm install --save 或是npm install --save-dev

注意:
  1.使用 npm init -y 的时候一定要注意,项目名称不能是中文,否则报错
  2.npm init 生成package.json的时候,按照要求一步一步来
  3.如果是开发阶段需要的第三方包,使用 npm install --save-dev
  4.如果是运行阶段需要的第三方包,使用 npm install --save

package.json一些重要属性说明:
  name : 项目或是第三方包的名称,也是其它项目导入时require()中的名称
  description : 这个项目或是第三方包功能的描述
  main : 项目或是第三方包的入口文件
  license : 授权方式,一般写MIT
  keywords : 发布到npmjs中之后,其它开发者搜索我们这个第三方包的关键
  字
  scripts : 以后在终端执行的脚本
  devDependencies : 开发阶段依赖的包
  dependencies : 运行阶段依赖的包
  author : 作者
  version : 版本号
</code></pre><hr>
<h1 id="学习途径"><a href="#学习途径" class="headerlink" title="学习途径"></a>学习途径</h1><ol>
<li>看官方文档 <a href="https://nodejs.org/dist/latest-v6.x/docs/api/" target="_blank" rel="external">https://nodejs.org/dist/latest-v6.x/docs/api/</a></li>
<li>看论坛 <a href="https://cnodejs.org/" target="_blank" rel="external">https://cnodejs.org/</a></li>
<li>百度</li>
<li><a href="http://nodejs.cn/(腾讯写的" target="_blank" rel="external">http://nodejs.cn/(腾讯写的</a>)</li>
</ol>
<hr>
<h1 id="CPU处理指令集"><a href="#CPU处理指令集" class="headerlink" title="CPU处理指令集"></a>CPU处理指令集</h1><p>复杂的指令集: PC<br>  英特尔/AMD<br>  32位: x86<br>  64位: x64</p>
<p>简单指令集:手机<br>  32位: i386<br>  64位: armv7 arm7s armv10   A10</p>
<hr>
<h1 id="cmd控制台常用指令及powershell介绍"><a href="#cmd控制台常用指令及powershell介绍" class="headerlink" title="cmd控制台常用指令及powershell介绍"></a>cmd控制台常用指令及powershell介绍</h1><p>cmd是window下独有的<br>    cd 切换目录<br>    cls 清屏<br>    dir 显示文件目录<br>    tree 已树的形式来展示文件结构</p>
<p>powershell windows下面的另外一个终端<br>  它是兼容 window,linux,unix</p>
<p>  clear 清屏<br>  ls 显示文件目录<br>  cd 切换目录</p>
<div class="pagination"><a class="prev" href="/2017/03/19/hello-world/">上一篇</a></div><div class="copyright"><p>© 2017 <a href="http://yoursite.com">Lh</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ycwalker/hexo-theme-cutie" target="_blank">hexo-theme-cutie</a>.</p></div></article></body></html>